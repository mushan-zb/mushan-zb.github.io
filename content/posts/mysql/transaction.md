---
title: "MySQL 数据库事务"
date: 2019-03-04T17:30:00+08:00

author: "木杉"
categories: 
- MySQL
tags: 
- database
description: ""

draft: false
---

# MySQL 数据库事务
### 数据库事务的四大特性
* 原子性：事务所包含的操作要么全部成功，要么全部失败回滚
* 一致性：数据库必须从一个一致性状态变换到另一个一致性状态，事务执行前和执行后必须处于一致性状态
* 隔离性：多个事务同时执行时，事务之间不能相互影响
* 持久性：事务一旦提交，对数据库的改变将是永久性的，即使数据库系统遇到故障也不会丢失提交事务的操作

### 事务的隔离等级
#### 事务不考虑隔离可能出现的问题
* 脏读：在一个事务中读取了另一个未提交事务的数据
* 不可重复读：在一个事务中多次查询却返回了不同的数据，主要是由于其他事务在查询隔离期间读取了其他事务已提交的数据
* 幻读：事务非独立执行时发生的一种现象。如：一个事务对全表进行了修改，但另一个事务新插入了一条数据，在该事务执行之前插入。将会导致好像还有一行数据没有进行修改的假象

#### 事务的四个隔离等级
* Read uncommitted (读未提交)：最低等级，以上三种问题全都未解决
    * 原理：对读取数据不加锁。更新数据时，先加行级共享锁，直到事务结束才释放
    * 表现：事务1读取某行记录时，事务2也能对该记录读取和更新，当事务2更新该记录时，事务1再次读取记录能读到修改中的数据。事务1更新该记录时，事务2不能对该记录进行更新，直到事务1结束
* Read committed (读已提交)：解决脏读问题
    * 原理：对读取的数据添加行级共享锁，一旦读完立即释放该锁。更新数据时，先添加行级排他锁，直到事务结束才释放
    * 表现：事务1读取某行记录时，事务2也能对该记录读取和更新，当事务2更新该记录时，事务1再次读取记录，只能读到事务2对该记录更新前或更新后的数据。事务1更新该记录时，事务2不能对该记录进行更新，直到事务1结束
* Repeatable read (可重复读)：解决脏读、不可重复读问题
    * 原理：对读取的数据添加行级共享锁，直到事务结束才释放。更新数据时，先添加行级排他锁，直到事务结束才释放
    * 表现：事务1读取某行记录，事务2也能对该纪录读取和更新，当事务2更新该记录时，事务1再次读取记录，只能读到事务2对该记录更新前的数据。事务1更新该记录时，事务2不能对该记录进行更新，直到事务1结束
* Serializable (串行化)：解决以上三种问题
    * 原理：对读取的数据添加表级共享锁，直到事务结束才释放。更新数据时，先添加表级排他锁，直到事务结束才释放
    * 表现：事务1读取某表的中的记录时，事务2也能读取该表记录，但不能对该表进行更新、插入和删除，直到事务1结束。事务1更新该表记录时，事务2不能对该表进行增删改查等任何操作，直到事务1结束

#### 隔离等级的实现原理
* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率高，并发度最低
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度最高
* 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般

表级锁适合查询为主，只有少量按索引条件更新数据的应用，行级锁有大量按索引条件并发更新少量不同数据，同时并发查询的应用
